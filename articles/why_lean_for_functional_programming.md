---
title: "関数型プログラミングの考え方を学ぶなら Haskell より Lean Prover がオススメ!?"
emoji: "🥇"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["lean", "lean4", "定理証明支援系", "関数型プログラミング", "Haskell"]
published: true
---

[Lean4](https://lean-lang.org/) というプログラミング言語をご存じでしょうか？

* 純粋関数型言語
* 型システムが強力
* 書いたコードの振る舞いを形式的に証明できる

と，他では珍しいユニークな特徴を備えたモダンな言語です．定理証明支援系(theorem prover)としての機能も持っているので，Lean Prover とも呼ばれます．

純粋関数型言語といえば Haskell だと思っていませんか？Haskell は素晴らしい言語ですが，実は Lean4 もすごく良いんですよ．

本記事では Haskell と比較した長所を紹介しながら，この Lean4 というまだ新しい言語についてご説明します．

## 長所1: フィールドを取得する関数がグローバルにならない

Haskell では，新しい型を定義するとフィールドの値を取得する関数が自動的に作られます．

たとえば，Haskell で2次元平面を表す型を作った場合のことを例に考えてみましょう．

```haskell:haskell
data Point2D = MkPoint2D { x::Int, y::Int }
  deriving Show

-- 2次元平面上の点A(0, 1)
point_A = MkPoint2D 0 1

main :: IO ()
main = do
  print $ x point_A
```

上記のコードの出力 (`print` の出力) は `0` です．`x` というのがx軸の値を取り出す関数 `Point2D -> Int` になっているからです．


何の問題もないように見えますが，ここで更に「3次元空間を表す型」を追加で作ってみると問題が露呈します．

```diff haskell:haskell
data Point2D = MkPoint2D { x::Int, y::Int }
  deriving Show

+ -- 3次元空間
+ data Point3D = Point3D { x::Int, y::Int, z::Int }

point_A = MkPoint2D 0 1

main :: IO ()
main = do
  print $ x point_A
```

コンパイルエラーになるのです．エラーの原因は，`x :: Point2D -> Int` という平面のx座標を取り出す関数と `x :: Point3D -> Int` という空間のx座標を取り出す関数がどちらもグローバルに定義されており，**名前被り** を起こしてしまっていることです．適当な接頭辞を付けて `Point2D_x` などと名前を変えることで解決できないことはないですが，そもそもグローバルにゲッタを定義してしまう Haskell 側の問題であると思います．

Lean4 では，この問題は起こりません. 上記のコードを Lean4 で書き直すと次のようになります．

@[gist](https://gist.github.com/Seasawher/8fd11eff0dd288e1bf8267afd6077ca7)

ご覧の通り，x軸の値にアクセスする関数は `Point2D.x` であり，構造体の名前が自動的に頭につきます．ですから，`Point3D` を定義しても名前が被る心配はありません．更に，`point_A` にドット記法で(**まるでメソッドであるかのように**)直接 `x` をつなげて `point_A.x` と書くことでも同じ結果を得ることができます．

## 長所2: パターンマッチの構文が簡潔

関数型プログラミングでは，パターンマッチを多用します．たとえば，フィボナッチ数列の素朴な定義を Haskell で書き下すと以下のようになります．

```haskell:haskell
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)
```

`fib` が何度も出てきますね．一方で同じ式を Lean4 に素直に翻訳するとこうなります．

@[gist](https://gist.github.com/Seasawher/d557736a94e6f348e26ea0d12d51edab)

`fib` の繰り返しがなくなり，より簡潔になりますね．また，Haskell では使用できない `0, 1, n + 2` というパターンマッチが使用できる点もおもしろいところです．

## 長所3: 正格評価である

Haskell は，評価戦略として遅延評価を採用しています．参照透過性が担保されているからこそできることなのですが，入門書で宣伝されているほど便利ではないと思います．思った順番で操作を実行することが難しくなりますし，デバッグもやりにくくなります．

ここでは遅延評価の便利さの話には深く踏み込みませんが，少なくとも関数型プログラミングを学びたくて Haskell に挑戦している方にとっては，遅延評価に付きまとう数々の固有の振る舞いは，障害にしかならないと思います．

Lean4 は正格評価なので，遅延評価のことを一切気にせずに関数型プログラミングに集中できます．

## 長所4: UI がよりわかりやすい

Lean4 では，`#eval` というコマンドにより式の値をその場で（ターミナルを開くことなく）確かめることができます．型をチェックしたいときには `#check` コマンドがあります．どちらも，マウスオーバーするだけで値が表示されます．先ほどのフィボナッチ数列の例でよろしければ，[こちら](https://t.ly/d_0Wa) から実際に試すことができます．

jupyter notebook のような便利な機能が，最初から搭載されているわけです．

## 長所5: 再帰関数が停止することを自動的に検証してくれる

関数型プログラミングは「簡単なことを難しくやっている」と言われることがあります．確かに手続き型の言語なら For 文で書けるようなループであっても再帰を使って実装し，わざわざ無限ループになるリスクを負うのは，最初は奇妙に映りました．関数型プログラミングはすべてに型をつけることによる安全性の向上が利点，といわれているだけに猶更です．

しかし Lean4 (および定理証明支援系としての機能を持つ言語) では，そのリスクは大きくありません．関数を定義した時点で，自動的に Lean が停止するかどうか証明を試み，失敗すれば警告してくれるからです．

どうしても停止するとは限らない関数を使用しなくてはならないときは，`partial` とマークすることで使うことができますよ．

## まとめ

純粋関数型言語というと Haskell が有名ですが，Lean4 は後発の言語らしく，先行する言語の問題点を解決してモダンなつくりになっています．この記事では深く触れませんでしたが，Lean4 は定理証明支援系としての機能も大変強力であり，「数学らしい」書き方ができるようになっています．

まだバージョン4が正式リリースされて間もないということもあり，明日業務で使うかもというような言語ではありませんが，興味を持っていただけたら幸いです．